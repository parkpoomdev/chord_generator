<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>24-Fret Fretboard Chord Suggester</title>
    <!-- Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Configure Tailwind for custom colors and font --><script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-dark': '#1e293b',
                        'secondary-light': '#cbd5e1',
                        'fret-wood-dark': '#4a2c0f', /* Deeper wood color */
                        'fret-wood-light': '#654321', /* Original, fallback */
                        'inlay': '#ffd700', /* Brighter gold for inlays */
                        'suggest-1': '#ef4444', // Red
                        'suggest-2': '#3b82f6', // Blue
                        'suggest-3': '#10b981', // Green
                        'suggest-4': '#f97316', // Orange
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom CSS for Fretboard Look (Simple/Modern Redesign) */
        #fretboard-grid {
            overflow: hidden; 
            max-width: 100%;
            aspect-ratio: 52 / 9;
            position: relative;
            padding-right: 110px;
        }

        .fretboard-container {
            width: 100%;
            height: 100%; 
            padding: 1.5rem 1.1rem;
            background-color: #f7fafc;
            box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.05);
            position: relative;
            border-radius: 1rem;
        }
        
        /* New Nut Line Style (Fret 0) */
        .nut-line {
            width: 8px;
            position: absolute;
            height: 100%;
            top: 0;
            background-color: #111827;
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.4);
            z-index: 15;
        }

        .fret-line {
            width: 2px;
            background-color: #cbd5e1;
            box-shadow: none;
            z-index: 10;
            position: absolute;
            height: 100%;
            top: 0;
            left: 0;
            right: auto;
        }

        .string-line {
            height: 1px;
            width: 100%;
            background-color: rgba(15, 23, 42, 0.7);
            z-index: 20;
            cursor: pointer;
        }

        .note-dot {
            width: 15px;
            height: 15px;
            cursor: pointer;
            border-radius: 9999px;
            position: absolute;
            z-index: 30;
            transform: translateY(-50%);
            transition: transform 0.1s ease, opacity 0.2s ease, background-color 0.2s ease, border-color 0.2s ease;
            background-color: transparent;
            border: 1px solid transparent;
            opacity: 0;
            pointer-events: all;
        }

        .open-slot {
            position: absolute;
            top: 0;
            bottom: 0;
            border-left: 1px solid rgba(55, 65, 81, 0.3);
            border-right: 1px solid rgba(55, 65, 81, 0.4);
            background: rgba(15, 23, 42, 0.04);
            pointer-events: none;
            z-index: 12;
        }

        .open-string-column {
            position: absolute;
            top: 0.8rem;
            bottom: 0.8rem;
            right: -96px;
            width: 96px;
            background: linear-gradient(90deg, rgba(15,23,42,0.08), rgba(15,23,42,0));
            border-left: 1px solid rgba(148,163,184,0.7);
            padding: 0.5rem 0;
            color: #475569;
            font-size: 0.68rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            z-index: 5;
        }
        .open-string-column .open-string-header {
            text-align: center;
            font-weight: 600;
            margin-bottom: 0.6rem;
        }

        .open-string-row {
            font-size: 0.52rem;
            text-align: center;
            letter-spacing: 0.2em;
            margin-bottom: 0.5rem;
        }

        .open-string-note {
            position: absolute;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: 600;
            background: rgba(15, 23, 42, 0.08);
            padding: 0.05rem 0.3rem;
            border-radius: 9999px;
        }

        .note-dot:hover {
            opacity: 1;
            transform: scale(1.1) translateY(-50%);
            background-color: rgba(37, 99, 235, 0.15);
            border-color: rgba(37, 99, 235, 0.4);
        }

        .note-dot.is-selected {
            opacity: 1;
            transform: scale(1.15) translateY(-50%);
        }

        /* Fret Inlays (Dots) */
        .fret-inlay {
            position: absolute;
            /* Simple Design: Darker, flat color, no glow */
            width: 14.4px; /* ลดลง 20% จาก 18px */
            height: 14.4px; 
            border-radius: 9999px;
            background-color: #4b5563; /* Gray-600 */
            opacity: 1; 
            box-shadow: none;
            z-index: 5;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Styles for fret numbers and string labels */
        .fret-number-label {
            position: absolute; 
            top: calc(100% + 5px); 
            text-align: center; 
            font-size: 0.875rem; 
            font-weight: 500; 
            color: #4b5563; 
            width: 40px; 
            transform: translateX(-50%); 
        }

        .string-label {
            position: absolute;
            right: calc(100% + 15px); 
            font-weight: 600; 
            font-size: 1.125rem; 
            color: #1f2937; /* Gray-800 for high contrast */
            width: 32px; 
            text-align: right;
            top: 50%;
            transform: translateY(-50%);
        }

        /* New Simple Table Styles */
        .simple-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }
        .simple-table th, .simple-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e5e7eb; /* Gray-200 */
            text-align: left;
        }
        .simple-table th {
            background-color: #f9fafb; /* Gray-50 */
            font-weight: 600;
            color: #1f2937; /* Gray-800 */
        }
        .suggestion-row:hover {
            background-color: #eff6ff; /* Blue-50 on hover */
            cursor: pointer;
        }
        .action-button {
            background-color: #4f46e5; /* Indigo-600 */
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .action-button:hover {
            background-color: #4338ca; /* Indigo-700 */
        }
        .remove-button {
            background-color: #ef4444; /* Red-500 */
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .remove-button:hover {
            background-color: #dc2626; /* Red-600 */
        }
        /* Ensure mini fretboard SVGs are properly sized */
        .mini-fretboard-cell {
            width: 80px;
            text-align: center;
        }
        
        /* CARD AND DND STYLES REINTRODUCED */
        .chord-card {
            /* Minimalist Card Style for Progression */
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            position: relative;
            width: 150px; /* Fixed width for card */
            text-align: center;
            color: white; /* Ensure text is visible on colored background */
            cursor: grab; /* Indicates draggable */
        }
        .chord-card:hover {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .chord-card.dragging {
            opacity: 0.4;
            border: 2px dashed #6366f1; /* Indigo */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans min-h-screen p-4 md:p-8">

    <div id="app-container" class="w-full max-w-none space-y-8">
        <header class="text-center pb-4 border-b border-gray-300">
            <h1 class="text-4xl font-extrabold text-primary-dark tracking-tight">Fretboard 24 เฟรต &amp; เครื่องมือสร้างคอร์ด</h1>
            <p class="text-gray-600 mt-2">แตะโน้ตอย่างน้อย 3 ตัวบนลำคอเพื่อให้ระบบแนะนำคอร์ดและสร้างลำดับคอร์ดให้คุณ</p>
        </header>

        <!-- 1. Fretboard Display Area -->
        <section id="fretboard-section" class="bg-white p-6 md:p-8 rounded-3xl shadow-2xl space-y-6">
            <div class="flex flex-col gap-2 md:flex-row md:items-end md:justify-between">
                <div>
                    <h2 class="text-3xl font-semibold text-primary-dark">Fretboard (E Standard) · 24 เฟรต</h2>
                    <p class="text-sm text-gray-500 mt-1 max-w-2xl">คอกีตาร์อยู่ทางขวา · เลือกโน้ตเพื่อดูคำแนะนำแบบเรียลไทม์บนหน้าแสดงผลกว้างเต็มจอ</p>
                </div>
                <div class="text-right text-sm text-gray-500 uppercase tracking-wider">
                    Fret 24 ------ Fret 1 | Fret 0 (สายเปิด)
                </div>
            </div>
            <div class="flex items-center gap-3 text-[0.65rem] font-semibold text-gray-400 uppercase tracking-[0.3em]">
                <span>Fret 24</span>
                <span class="flex-1 h-px bg-gray-300"></span>
                <span>Fret 1</span>
                <span class="flex-1 h-px bg-gray-300"></span>
                <span class="whitespace-nowrap">Fret 0 (สายเปิด)</span>
            </div>
            <p class="text-xs text-gray-500 italic font-light">กด 0 หรือคลิกตำแหน่ง Fret 0 เพื่อเลือกสายเปิด</p>
            <div id="fretboard-grid" class="relative w-full aspect-[52/9]">
                <div id="fretboard-container" class="fretboard-container relative">
                    <!-- Fret lines, Inlays, and Strings will be generated by JS -->
                </div>
            </div>
            <div class="grid gap-3 md:grid-cols-[1fr_auto] md:items-center">
                <div id="current-selection" class="text-lg font-medium text-gray-700">
                    โน้ตที่เลือก: <span id="selected-notes-display" class="font-bold text-indigo-600">--</span>
                </div>
                <button id="clear-button" class="self-end bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow transition duration-150">
                    ล้างการเลือก
                </button>
            </div>
            <div id="suggestions-section" class="space-y-4">
                <h2 class="text-2xl font-semibold text-primary-dark">คำแนะนำคอร์ด: <span id="suggested-chord-name" class="text-teal-600">--</span></h2>
                <div id="suggested-voicings-container" class="overflow-x-auto">
                    <p id="suggestion-placeholder" class="text-gray-500 italic p-4">เลือกโน้ตบน Fretboard เพื่อดูคำแนะนำในรูปแบบตาราง</p>
                    <!-- Suggested chord table will be inserted here -->
                </div>
            </div>
            <div id="progression-section" class="space-y-4">
                <h2 class="text-2xl font-semibold text-primary-dark">ลำดับคอร์ด (สูงสุด 7 คอร์ด)</h2>
                <div id="progression-container" class="flex flex-wrap gap-4 p-4 border-2 border-dashed border-gray-300 rounded-xl items-start min-h-[100px]">
                    <p id="progression-placeholder" class="text-gray-500 italic w-full text-center">ลากคอร์ดที่แนะนำลงในพื้นที่นี้เพื่อสร้างลำดับเสียง</p>
                    <!-- Chord Cards will be dynamically inserted here -->
                </div>
            </div>
        </section>

        <!-- Segment Composer moved to the right of Fretboard -->
        <!-- Segment Composer: Drag/Drop + Playback -->
        <section id="segment-composer" class="bg-white p-4 rounded-xl shadow-lg">
            <h2 class="text-2xl font-semibold mb-4 text-primary-dark">ตัวเรียบเรียง Segment & Playback</h2>

            <!-- Transport / Meter Controls -->
            <div class="flex flex-wrap items-end gap-4 mb-4">
                <div>
                    <label for="seg-bpm" class="block text-sm font-medium text-gray-700">Tempo (BPM)</label>
                    <input id="seg-bpm" type="number" min="30" max="240" value="100" class="mt-1 w-28 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" />
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Time Signature</label>
                    <div class="mt-1 flex items-center gap-2">
                        <select id="seg-time-num" class="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                            <option>4</option>
                            <option>3</option>
                            <option>2</option>
                            <option>6</option>
                        </select>
                        <span class="text-gray-500">/</span>
                        <select id="seg-time-den" class="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                            <option>4</option>
                            <option>8</option>
                        </select>
                    </div>
                </div>
                <label class="inline-flex items-center gap-2 select-none">
                    <input id="seg-metronome" type="checkbox" class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" />
                    <span class="text-sm text-gray-700">Metronome</span>
                </label>
                <div class="ml-auto flex items-center gap-2">
                    <button id="seg-play" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg">Preview</button>
                    <button id="seg-stop" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg">Stop</button>
                </div>
            </div>

            <!-- Chord Palette -->
            <div class="mb-4">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-lg font-semibold text-primary-dark">Chord Palette</h3>
                    <div class="flex items-center gap-2">
                        <input id="seg-custom-chord" placeholder="พิมพ์คอร์ด เช่น Cmaj7, Am" class="w-56 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" />
                        <button id="seg-add-custom" class="bg-teal-600 hover:bg-teal-700 text-white font-semibold py-2 px-3 rounded-md">Add</button>
                    </div>
                </div>
                <div id="seg-palette" class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2"></div>
                <p class="text-xs text-gray-500 mt-1">ลากคอร์ดจาก Palette ไปวางใน Segment ด้านล่าง</p>
            </div>

            <!-- Segment Controls -->
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-lg font-semibold text-primary-dark">Segments</h3>
                <div class="flex items-center gap-2">
                    <button id="seg-add" class="bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-2 px-4 rounded-lg">+ Add Segment</button>
                    <button id="seg-clear" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg">Clear All</button>
                </div>
            </div>

            <!-- Segment List -->
            <div id="seg-list" class="flex flex-col"></div>
            <p class="text-xs text-gray-500 mt-2">การเล่นจะเริ่มจากด้านบน → ขวา แล้วลง Segment ถัดไป</p>
        </section>

        <!-- 2. Chord Suggestions Area moved into Fretboard card -->
        <!-- 3. Chord Progression moved into Fretboard card -->
        
        <!-- 4. Message Box (Alternative to alert()) --><div id="message-box" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center p-4 z-50">
            <div class="bg-white p-6 rounded-lg shadow-2xl max-w-sm w-full text-center">
                <p id="message-text" class="text-lg font-semibold mb-4"></p>
                <button onclick="hideMessageBox()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">ตกลง</button>
            </div>
        </div>

    </div>

    <script type="module">
        // Global variables for Firebase setup (required by the platform)
        const appId = window.__app_id || 'default-app-id';
        const firebaseConfig = window.__firebase_config ? JSON.parse(window.__firebase_config) : null;
        const initialAuthToken = window.__initial_auth_token || null;

        // --- Utility Functions ---
        function showMessageBox(message) {
            document.getElementById('message-text').textContent = message;
            document.getElementById('message-box').classList.remove('hidden');
            document.getElementById('message-box').classList.add('flex');
        }

        function hideMessageBox() {
            document.getElementById('message-box').classList.add('hidden');
            document.getElementById('message-box').classList.remove('flex');
        }

        // --- Fretboard and Music Theory Data ---
        const NOTES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const STANDARD_TUNING = [4, 9, 2, 7, 11, 4]; // E, A, D, G, B, E (0=C, 11=B)
        const NUM_STRINGS = 6;
        const NUM_FRETS = 24;
        const FRET_WIDTH_BASE = 70; 
        const TOTAL_FRETBOARD_PIXEL_WIDTH = 2400; // Not used for positioning anymore, kept for reference
        const FRET_WIDTH_UNITS = [36.37, 34.33, 32.40, 30.58, 28.87, 27.25, 25.72, 24.27, 22.91, 21.63, 20.41, 19.27, 18.18, 17.16, 16.20, 15.29, 14.43, 13.62, 12.86, 12.14, 11.46, 10.81, 10.21, 9.63];
        const OPEN_SLOT_UNITS = FRET_WIDTH_UNITS[0];

        // Common Chord Definitions (Intervals relative to the Root)
        const CHORD_INTERVALS = {
            "Major": [0, 4, 7],
            "Minor": [0, 3, 7],
            "Dom7": [0, 4, 7, 10],
            "Min7": [0, 3, 7, 10],
            "Maj7": [0, 4, 7, 11],
            "Sus4": [0, 5, 7],
        };

        // Movable Chord Shapes (Defined by fret offsets from the root fret 'R')
        const CHORD_SHAPES = {
            "E_Maj_Shape": [[5, 0], [4, 2], [3, 2], [2, 1], [1, 0], [0, 0]],
            "E_Min_Shape": [[5, 0], [4, 2], [3, 2], [2, 0], [1, 0], [0, 0]],
            "A_Maj_Shape": [[4, 0], [3, 2], [2, 2], [1, 2], [0, 0]], 
            "A_Min_Shape": [[4, 0], [3, 2], [2, 2], [1, 1], [0, 0]], 
        };

        // Unique colors for suggested voicings
        const SUGGESTION_COLORS = [
            'bg-suggest-1/70 ring-suggest-1', // Red
            'bg-suggest-2/70 ring-suggest-2', // Blue
            'bg-suggest-3/70 ring-suggest-3', // Green
            'bg-suggest-4/70 ring-suggest-4', // Orange
            'bg-purple-500/70 ring-purple-500',
            'bg-pink-500/70 ring-pink-500',
            'bg-yellow-500/70 ring-yellow-500',
        ];
        const OPEN_STRING_MIDI = [64, 59, 55, 50, 45, 40];
        const audioState = { ctx: null };

        function ensureAudioContext() {
            if (!audioState.ctx) {
                audioState.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }

            return audioState.ctx;
        }

        function playChordAudio(notes, instrument = 'piano', duration = 1.2) {
            const ctx = ensureAudioContext();
            const t0 = ctx.currentTime + 0.02;
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.0001, t0);
            gain.connect(ctx.destination);
            gain.gain.exponentialRampToValueAtTime(0.25, t0 + 0.08);
            gain.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);
            const oscType = instrument === 'guitar' ? 'triangle' : 'sine';
            const usedMidis = new Set();
            notes.forEach(note => {
                const midiBase = OPEN_STRING_MIDI[note.string] ?? OPEN_STRING_MIDI[0];
                const midi = midiBase + note.fret;
                if (usedMidis.has(midi)) return;
                usedMidis.add(midi);
                const freq = 440 * Math.pow(2, (midi - 69) / 12);
                const osc = ctx.createOscillator();
                osc.type = oscType;
                osc.frequency.setValueAtTime(freq, t0);
                osc.connect(gain);
                osc.start(t0);
                osc.stop(t0 + duration + 0.1);
            });
        }

        // --- Main Application Class ---
        class FretboardApp {
            constructor() {
                this.selectedNotes = []; 
                this.progression = []; 
                this.progressionLimit = 7;
                this.db = null;
                this.auth = null;
                this.userId = null;
                this.doc = null;
                this.setDoc = null;
                this.onSnapshot = null;
                this.draggedItem = null; // Property to hold the dragged card element
                
                this.dom = {
                    fretboardContainer: document.getElementById('fretboard-container'),
                    selectedNotesDisplay: document.getElementById('selected-notes-display'),
                    suggestionsContainer: document.getElementById('suggested-voicings-container'),
                    progressionContainer: document.getElementById('progression-container'),
                    suggestedChordName: document.getElementById('suggested-chord-name'),
                    suggestionPlaceholder: document.getElementById('suggestion-placeholder'),
                    progressionPlaceholder: document.getElementById('progression-placeholder'),
                    clearButton: document.getElementById('clear-button'),
                };
                
                this.initFirebase();
                this.setupListeners();
                this.renderFretboard();
                this.renderProgression(); 
            }
            
            async initFirebase() {
                if (!firebaseConfig) {
                    console.warn("Firebase config not found. Persistence disabled.");
                    return;
                }

                try {
                    const { initializeApp } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js");
                    const { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js");
                    
                    const firestoreModule = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js");
                    const { getFirestore, doc, setDoc, onSnapshot, setLogLevel } = firestoreModule;

                    this.doc = doc;
                    this.setDoc = setDoc;
                    this.onSnapshot = onSnapshot;

                    setLogLevel('debug');

                    const app = initializeApp(firebaseConfig);
                    this.db = getFirestore(app);
                    this.auth = getAuth(app);

                    onAuthStateChanged(this.auth, async (user) => {
                        if (user) {
                            this.userId = user.uid;
                            this.setupFirestoreListener();
                        } else {
                            if (initialAuthToken) {
                                await signInWithCustomToken(this.auth, initialAuthToken);
                            } else {
                                await signInAnonymously(this.auth);
                            }
                        }
                    });

                } catch (error) {
                    console.error("Error initializing Firebase:", error);
                }
            }

            setupFirestoreListener() {
                if (this.db && this.userId) {
                    const progressionDocRef = this.doc(this.db, `artifacts/${appId}/users/${this.userId}/progression_data`, 'current_progression');
                    
                    this.onSnapshot(progressionDocRef, (docSnap) => {
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            this.progression = JSON.parse(data.progressionJson || '[]');
                            this.renderProgression();
                            console.log("Progression loaded from Firestore.");
                        } else {
                            this.saveProgression(); 
                        }
                    }, (error) => {
                        console.error("Error listening to progression:", error);
                    });
                }
            }

            async saveProgression() {
                if (this.db && this.userId) {
                    try {
                        const progressionDocRef = this.doc(this.db, `artifacts/${appId}/users/${this.userId}/progression_data`, 'current_progression');
                        const dataToSave = {
                            progressionJson: JSON.stringify(this.progression),
                            updatedAt: new Date().toISOString()
                        };
                        await this.setDoc(progressionDocRef, dataToSave, { merge: true });
                        console.log("Progression saved to Firestore.");
                    } catch (e) {
                        console.error("Error saving progression:", e);
                    }
                }
            }


            setupListeners() {
                this.dom.fretboardContainer.addEventListener('click', (e) => this.handleFretboardClick(e));
                this.dom.clearButton.addEventListener('click', () => this.clearSelection());
                
                // RE-ADDED DND LISTENERS
                this.dom.progressionContainer.addEventListener('dragstart', (e) => this.handleDragStart(e));
                this.dom.progressionContainer.addEventListener('dragover', (e) => this.handleDragOver(e));
                this.dom.progressionContainer.addEventListener('drop', (e) => this.handleDrop(e));
                this.dom.progressionContainer.addEventListener('dragleave', (e) => this.handleDragLeave(e));
            }

            // --- Fretboard Rendering ---

            renderFretboard() {
                const container = this.dom.fretboardContainer;
                container.innerHTML = '';
                
                // Calculate fixed pixel values for dot/line alignment
                const FRET_LINE_WIDTH_HALF_PX = 1; // 2px / 2
                const HALF_DOT_WIDTH_PX = 19.2 / 2; // 9.6px

                // Nut Line (Fret 0)
                const cumulativeUnits = [];
                FRET_WIDTH_UNITS.forEach((unit, idx) => {
                    const previous = idx === 0 ? 0 : cumulativeUnits[idx - 1];
                    cumulativeUnits.push(previous + unit);
                });
                const totalUnits = OPEN_SLOT_UNITS + cumulativeUnits[cumulativeUnits.length - 1];
                const slotWidthPercent = (OPEN_SLOT_UNITS / totalUnits) * 100;
                const openSlot = document.createElement('div');
                openSlot.className = 'open-slot';
                openSlot.style.width = `${slotWidthPercent}%`;
                openSlot.style.right = '0';
                container.appendChild(openSlot);

                const nut = document.createElement('div');
                nut.className = 'nut-line';
                nut.style.right = `${slotWidthPercent}%`;
                container.appendChild(nut);

                const sumBeforeFret = (fretIndex) => {
                    if (fretIndex <= 1) return 0;
                    return cumulativeUnits[fretIndex - 2];
                };
                const boundaryPercentFromRight = (fretIndex) => (OPEN_SLOT_UNITS + sumBeforeFret(fretIndex)) / totalUnits;
                const centerPercentFromRight = (fretIndex) => {
                    const before = sumBeforeFret(fretIndex);
                    const widthUnits = FRET_WIDTH_UNITS[fretIndex - 1];
                    return (OPEN_SLOT_UNITS + before + widthUnits / 2) / totalUnits;
                };
                const openCenterPercentFromRight = (OPEN_SLOT_UNITS / 2) / totalUnits;

                const openStringGuidance = document.createElement('div');
                openStringGuidance.className = 'open-string-column';
                openStringGuidance.innerHTML = `
                    <div class="open-string-header">
                        <div>Fret 0</div>
                        <div>???????</div>
                    </div>
                    <div class="open-string-row">GF#F || E ? Fret 0 Here</div>
                `;
                STANDARD_TUNING.forEach((pitch, idx) => {
                    const label = document.createElement('div');
                    label.className = 'open-string-note';
                    label.textContent = NOTES[pitch % NOTES.length];
                    const topPercent = (idx + 0.5) * (100 / NUM_STRINGS);
                    label.style.top = `${topPercent}%`;
                    openStringGuidance.appendChild(label);
                });
                container.appendChild(openStringGuidance);

                // Fret lines (Start from Fret 1)
                for (let i = 1; i <= NUM_FRETS; i++) {
                    const fret = document.createElement('div');
                    fret.className = `fret-line absolute`;
                    
                    // Responsive Fret Line Position (using pure percentages)
                    const leftPositionPercent = (1 - boundaryPercentFromRight(i)) * 100;
                    fret.style.left = `calc(${leftPositionPercent}% - ${FRET_LINE_WIDTH_HALF_PX}px)`; 
                    
                    // Fret number display (only for lower frets)
                    if (i <= 12 && (i % 2 !== 0 || i === 12)) {
                         const numLabel = document.createElement('div');
                         numLabel.textContent = i;
                         numLabel.className = 'fret-number-label'; 
                         numLabel.style.left = `calc(${leftPositionPercent}% - 2px)`;
                         fret.appendChild(numLabel);
                    }

                    container.appendChild(fret);
                }

                // Inlays (Frets 3, 5, 7, 9, 15, 17, 19, 21) and Double Inlays (12, 24)
                const inlayFrets = [3, 5, 7, 9, 15, 17, 19, 21];
                const doubleInlayFrets = [12, 24];
                
                // Responsive Inlay Position (Center of the slot)
                const getInlayCenterPercent = (fretIndex) => {
                    const widthUnits = FRET_WIDTH_UNITS[fretIndex - 1];
                    const unitsFromRight = OPEN_SLOT_UNITS + sumBeforeFret(fretIndex) + widthUnits / 2;
                    return (1 - (unitsFromRight / totalUnits)) * 100;
                }

                inlayFrets.forEach(fret => {
                    const pos = getInlayCenterPercent(fret);
                    const dot = document.createElement('div');
                    dot.className = 'fret-inlay';
                    dot.style.left = `calc(${pos}% - 10px)`; 
                    container.appendChild(dot);
                });

                doubleInlayFrets.forEach(fret => {
                    const pos = getInlayCenterPercent(fret);
                    const dotTop = document.createElement('div');
                    dotTop.className = 'fret-inlay';
                    dotTop.style.left = `calc(${pos}% - 10px)`;
                    dotTop.style.top = `33%`;
                    container.appendChild(dotTop);
                    
                    const dotBottom = document.createElement('div');
                    dotBottom.className = 'fret-inlay';
                    dotBottom.style.left = `calc(${pos}% - 10px)`;
                    dotBottom.style.top = `67%`;
                    container.appendChild(dotBottom);
                });

                // Strings and Note Slots
                for (let s = 0; s < NUM_STRINGS; s++) {
                    const stringLine = document.createElement('div');
                    const stringHeight = (s + 0.5) * (100 / NUM_STRINGS);
                    
                    stringLine.className = 'string-line absolute w-full';
                    stringLine.style.top = `${stringHeight}%`;
                    container.appendChild(stringLine);
                    
                    // Loop from Fret 0 (Open String)
                    for (let f = 0; f <= NUM_FRETS; f++) {
                        const noteDot = document.createElement('div');
                        noteDot.className = 'note-dot';

                        let dotLeft;

                        let centerPercent;
                        if (f === 0) {
                            centerPercent = (1 - openCenterPercentFromRight) * 100;
                        } else {
                            centerPercent = (1 - centerPercentFromRight(f)) * 100;
                        }
                        dotLeft = `calc(${centerPercent}% - ${HALF_DOT_WIDTH_PX}px)`; 

                        noteDot.style.left = dotLeft; 
                        noteDot.style.top = `${stringHeight}%`; 
                        
                        noteDot.dataset.string = s;
                        noteDot.dataset.fret = f;
                        
                        const pitch = (STANDARD_TUNING[s] + f) % 12;
                        noteDot.dataset.pitch = pitch;
                        
                        container.appendChild(noteDot);
                    }
                }
            }
            
            // Re-renders the selected notes and suggested chords on the Fretboard
            updateFretboard() {
                const noteDots = this.dom.fretboardContainer.querySelectorAll('.note-dot');
                noteDots.forEach(dot => {
                    dot.classList.remove('is-selected', 'bg-indigo-600', 'ring-indigo-600', 'ring-8');
                    dot.classList.remove(...SUGGESTION_COLORS.flatMap(c => c.split(' '))); // Remove suggestion colors
                    dot.style.opacity = 0;
                });
                
                // 1. Render Selected Notes
                this.selectedNotes.forEach(note => {
                    const dot = this.dom.fretboardContainer.querySelector(`[data-string="${note.string}"][data-fret="${note.fret}"]`);
                    if (dot) {
                        dot.classList.add('is-selected', 'bg-indigo-600', 'ring-indigo-600');
                        dot.style.opacity = 1; 
                    }
                });
                
                // 2. Chord Detection & Suggestions
                this.dom.suggestedChordName.textContent = '--';
                if (this.selectedNotes.length >= 3) {
                    const { chord, rootNote, voicings } = this.detectAndSuggestChord();
                    
                    if (chord) {
                        this.dom.suggestedChordName.textContent = `${rootNote} ${chord}`;
                        this.renderSuggestions(voicings);
                        
                        // 3. Render Suggestions on Fretboard
                        voicings.forEach((voicing, index) => {
                            const colorClasses = SUGGESTION_COLORS[index % SUGGESTION_COLORS.length];
                            voicing.notes.forEach(note => {
                                const dot = this.dom.fretboardContainer.querySelector(`[data-string="${note.string}"][data-fret="${note.fret}"]`);
                                if (dot && !dot.classList.contains('is-selected')) {
                                    dot.classList.remove('bg-gray-600', 'ring-gray-600'); // Remove default
                                    dot.classList.add('ring-8', ...colorClasses.split(' ')); // Add suggestion styles
                                    dot.style.opacity = 1; // Full opacity for suggested color
                                }
                            });
                        });
                    } else {
                        this.renderSuggestions([]); // Clear suggestions if no chord found
                    }
                } else {
                    this.renderSuggestions([]);
                }
                
                // Update selected notes display
                const selectedPitches = this.selectedNotes.map(n => NOTES[n.pitch]).join(', ');
                this.dom.selectedNotesDisplay.textContent = selectedPitches || '--';
            }

            // --- Chord Logic ---

            getSelectedPitches() {
                return [...new Set(this.selectedNotes.map(n => n.pitch))].sort((a, b) => a - b);
            }

            detectAndSuggestChord() {
                const pitches = this.getSelectedPitches();
                let bestMatch = { chord: null, root: -1, matches: 0 };
                
                for (let root = 0; root < 12; root++) {
                    const relativePitches = pitches.map(p => (p - root + 12) % 12).sort((a, b) => a - b);
                    
                    for (const [chordType, intervals] of Object.entries(CHORD_INTERVALS)) {
                        const isSubset = intervals.every(interval => relativePitches.includes(interval));
                        
                        if (isSubset && intervals.length > bestMatch.matches) {
                            bestMatch = { chord: chordType, root: root, matches: intervals.length };
                        }
                    }
                }

                if (bestMatch.chord) {
                    const rootNote = NOTES[bestMatch.root];
                    const voicings = this.suggestVoicings(bestMatch.root, bestMatch.chord);
                    return { chord: bestMatch.chord, rootNote, voicings };
                }

                return { chord: null, rootNote: null, voicings: [] };
            }

            suggestVoicings(rootPitch, chordType) {
                const suggestedVoicings = [];
                let shapeKeys = [];
                
                if (chordType.includes('Maj') || chordType.includes('Sus')) {
                    shapeKeys = ["E_Maj_Shape", "A_Maj_Shape"];
                } else if (chordType.includes('Min')) {
                    shapeKeys = ["E_Min_Shape", "A_Min_Shape"];
                } else if (chordType.includes('Dom')) {
                    shapeKeys = ["E_Maj_Shape", "A_Maj_Shape"];
                }

                let voicingId = 0;
                
                shapeKeys.forEach(shapeKey => {
                    const shape = CHORD_SHAPES[shapeKey];
                    const rootStringIndex = shape.find(s => s[1] === 0)?.[0] || shape[0][0]; 
                    
                    // Root fret can also be 0 (open chord position)
                    for (let rootFret = 0; rootFret <= NUM_FRETS - 4; rootFret++) {
                        // Skip if the user has already selected a note at this root fret, 
                        // unless it's fret 0 which is often used.
                        // For simplicity in suggestion generation, we don't strictly enforce skipping selection check here.
                        // if (this.selectedNotes.some(n => n.fret === rootFret)) continue;

                        const voicing = {
                            id: `v${voicingId++}`,
                            chordName: `${NOTES[rootPitch]} ${chordType}`,
                            rootFret: rootFret,
                            notes: []
                        };

                        shape.forEach(([stringOffset, fretOffset]) => {
                            const stringIndex = NUM_STRINGS - 1 - stringOffset;
                            const fret = rootFret + fretOffset;
                            const pitch = (STANDARD_TUNING[stringIndex] + fret) % 12;

                            const relativePitch = (pitch - rootPitch + 12) % 12;
                            const intervals = CHORD_INTERVALS[chordType];

                            if (fret <= NUM_FRETS && intervals.includes(relativePitch)) {
                                voicing.notes.push({ string: stringIndex, fret: fret, pitch: pitch });
                            } else if (fret <= NUM_FRETS && fretOffset !== 0) {
                                if (fretOffset > 0) {
                                     voicing.notes.push({ string: stringIndex, fret: fret, pitch: pitch });
                                }
                            }
                        });
                        
                        const actualRootPitch = (STANDARD_TUNING[rootStringIndex] + rootFret) % 12;
                        if (voicing.notes.length >= 3 && actualRootPitch === rootPitch) {
                            suggestedVoicings.push(voicing);
                        }
                    }
                });

                // Prioritize voicings with roots between frets 3-5, but still show the same chord across the neck
                const inRange = suggestedVoicings.filter(v => v.rootFret >= 3 && v.rootFret <= 5);
                const outOfRange = suggestedVoicings.filter(v => v.rootFret < 3 || v.rootFret > 5);
                outOfRange.sort((a, b) => Math.abs(a.rootFret - 4) - Math.abs(b.rootFret - 4));
                const blended = [...inRange, ...outOfRange];
                return blended.slice(0, 7);
            }

            // --- UI Interaction Handlers ---

            handleFretboardClick(e) {
                const dot = e.target.closest('.note-dot');
                if (!dot) return;

                const string = parseInt(dot.dataset.string);
                const fret = parseInt(dot.dataset.fret);
                const pitch = parseInt(dot.dataset.pitch);
                
                const indexByString = this.selectedNotes.findIndex(n => n.string === string);

                if (indexByString > -1) {
                    const existing = this.selectedNotes[indexByString];

                    if (existing.fret === fret) {
                        this.selectedNotes.splice(indexByString, 1);
                        this.updateFretboard();
                        return;
                    }

                    this.selectedNotes.splice(indexByString, 1);
                }

                this.selectedNotes.push({ string, fret, pitch });

                this.updateFretboard();
            }

            clearSelection() {
                this.selectedNotes = [];
                this.updateFretboard();
                this.dom.suggestedChordName.textContent = '--';
            }
            
            // --- Suggestions Rendering (TABLE) ---

            renderSuggestions(voicings) {
                const container = this.dom.suggestionsContainer;
                container.innerHTML = '';
                
                if (voicings.length === 0) {
                    this.dom.suggestionPlaceholder.classList.remove('hidden');
                    container.appendChild(this.dom.suggestionPlaceholder); 
                    return;
                }
                this.dom.suggestionPlaceholder.classList.add('hidden');

                // Start building the table structure
                let tableHTML = `
                    <table class="simple-table">
                        <thead>
                            <tr>
                                <th class="w-1/4">คอร์ด</th>
                                <th class="w-1/4">Fret เริ่ม</th>
                                <th class="w-1/4 mini-fretboard-cell">รูปแบบ · Fret แรก-สุดท้าย</th>
                                <th class="w-1/4">จัดการ</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                const sortedVoicings = [...voicings].sort((a, b) => b.rootFret - a.rootFret);
                sortedVoicings.forEach((voicing, index) => {
                    const colorClasses = SUGGESTION_COLORS[index % SUGGESTION_COLORS.length];
                    const bgColor = colorClasses.split(' ').find(c => c.startsWith('bg-'));

                    const frets = voicing.notes.map(n => n.fret).sort((a, b) => a - b);
                    const firstFret = frets[0];
                    const lastFret = frets[frets.length - 1];
                    const rangeText = firstFret === lastFret ? `Fret ${firstFret}` : `Fret ${lastFret} - Fret ${firstFret}`;
                    const miniFretboardSvg = this.renderMiniFretboard(voicing.notes, bgColor);

                    tableHTML += `
                        <tr data-voicing-id="${voicing.id}" class="suggestion-row">
                            <td>${voicing.chordName}</td>
                            <td>Fret ${voicing.rootFret}</td>
                            <td class="mini-fretboard-cell text-sm">
                                <div class="flex flex-col items-center gap-1">
                                    <span class="text-xs font-semibold text-gray-600">${rangeText}</span>
                                    <div class="w-full">${miniFretboardSvg}</div>
                                </div>
                            </td>
                            <td>
                                <div class="flex items-center gap-2">
                                    <button class="action-button preview-voicing" data-voicing-id="${voicing.id}" data-instrument="piano">Preview</button>
                                    <button class="action-button add-button" data-voicing-id="${voicing.id}">+</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });
                tableHTML += `</tbody></table>`;
                
                container.innerHTML = tableHTML;
                
                // Add event listeners to the new buttons
                container.querySelectorAll('.add-button').forEach(button => {
                    // FIX: Changed button.dataset.voicing-id to button.dataset.voicingId (camelCase)
                    const voicingId = button.dataset.voicingId; 
                    const voicing = voicings.find(v => v.id === voicingId);
                    if (voicing) {
                        button.addEventListener('click', (e) => {
                            e.stopPropagation(); 
                            this.addProgressionCard(voicing);
                        });
                    }
                });
                container.querySelectorAll('.preview-voicing').forEach(button => {
                    const voicingId = button.dataset.voicingId;
                    const voicing = voicings.find(v => v.id === voicingId);
                    if (voicing) {
                        button.addEventListener('click', (e) => {
                            e.stopPropagation();
                            playChordAudio(voicing.notes, button.dataset.instrument || 'piano');
                        });
                    }
                });
            }

            
            // Creates a small SVG representation of the chord voicing
            renderMiniFretboard(notes, bgColor) {
                const frets = notes.map(n => n.fret);
                const minFret = Math.min(...frets);
                const maxFret = Math.max(...frets);
                const startFret = Math.max(0, minFret - 1);
                const endFret = Math.max(maxFret, startFret + 2);
                const numMiniFrets = Math.max(3, endFret - startFret + 1);

                const width = 96;
                const height = 48;
                const stringSpacing = height / (NUM_STRINGS - 1);
                const fretSpacing = width / numMiniFrets;

                let svg = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" class="mx-auto">`;

                const highlightX = (minFret - startFret) * fretSpacing;
                const highlightWidth = (maxFret - minFret + 1) * fretSpacing;
                svg += `<rect x="${highlightX}" y="0" width="${highlightWidth}" height="${height}" rx="6" fill="rgba(59, 130, 246, 0.08)" />`;

                // Strings
                for (let s = 0; s < NUM_STRINGS; s++) {
                    const y = s * stringSpacing;
                    svg += `<line x1="0" y1="${y}" x2="${width}" y2="${y}" stroke="#94a3b8" stroke-width="0.4"/>`;
                }

                // Frets
                for (let f = 0; f <= numMiniFrets; f++) {
                    const x = f * fretSpacing;
                    const actualFret = startFret + f;
                    const strokeWidth = (actualFret === 0) ? 2 : 1;
                    svg += `<line x1="${x}" y1="0" x2="${x}" y2="${height}" stroke="#475569" stroke-width="${strokeWidth}"/>`;
                }

                notes.forEach(note => {
                    const stringIndex = note.string;
                    const fretPos = note.fret - startFret;
                    const cx = fretPos * fretSpacing + (fretSpacing / 2);
                    const cy = stringIndex * stringSpacing;

                    if (cx >= 0 && cx <= width) {
                        svg += `<circle cx="${cx}" cy="${cy}" r="3.5" fill="${bgColor.replace('bg-', '#').replace('/70', '')}" stroke="#fff" stroke-width="0.4"/>`;
                    }
                });

                svg += `</svg>`;
                return svg;
            }

            // --- Progression Logic (DND Card Reimplementation) ---

            addProgressionCard(voicing) {
                if (this.progression.length >= this.progressionLimit) {
                    showMessageBox(`ลำดับคอร์ดเต็มแล้ว! (จำกัดสูงสุด ${this.progressionLimit} คอร์ด)`);
                    return;
                }
                
                const newCard = {
                    id: crypto.randomUUID(),
                    chordName: voicing.chordName,
                    rootFret: voicing.rootFret,
                    notes: voicing.notes,
                    color: SUGGESTION_COLORS[this.progression.length % SUGGESTION_COLORS.length].split(' ').find(c => c.startsWith('bg-')),
                };
                
                this.progression.push(newCard);
                this.renderProgression();
                this.saveProgression();
            }
            
            removeProgressionCard(id) {
                const index = this.progression.findIndex(c => c.id === id);
                if (index > -1) {
                    this.progression.splice(index, 1);
                    this.renderProgression();
                    this.saveProgression();
                }
            }

            renderProgression() {
                const container = this.dom.progressionContainer;
                container.innerHTML = '';
                
                if (this.progression.length === 0) {
                    this.dom.progressionPlaceholder.classList.remove('hidden');
                    container.appendChild(this.dom.progressionPlaceholder);
                    return;
                }
                this.dom.progressionPlaceholder.classList.add('hidden');
                
                // Render Cards horizontally
                this.progression.forEach((cardData, index) => {
                    const bgColor = cardData.color;
                    const miniFretboardSvg = this.renderMiniFretboard(cardData.notes, bgColor);
                    
                    const card = document.createElement('div');
                    // Use flex/col and align center for card content
                    card.className = `chord-card ${bgColor} flex flex-col items-center justify-between shadow-md`; 
                    card.draggable = true;
                    card.dataset.id = cardData.id;
                    card.dataset.index = index;
                    card.dataset.chordName = cardData.chordName;
                    
                    card.innerHTML = `
                        <button class="remove-btn absolute top-1 right-1 p-1 text-white opacity-70 hover:opacity-100 hover:scale-110 transition" data-id="${cardData.id}">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                        </button>
                        <div class="flex w-full items-center justify-between mb-2">
                            <span class="text-xs font-semibold opacity-70">${index + 1}. Fret ${cardData.rootFret}</span>
                            <button class="action-button preview-card text-[0.65rem] px-3 py-1" data-instrument="guitar">Preview</button>
                        </div>
                        <div class="text-2xl font-black">${cardData.chordName}</div>
                        <div class="mt-2 h-10 w-full flex items-center justify-center">
                            ${miniFretboardSvg}
                        </div>
                    `;
                    
                    container.appendChild(card);
                    
                    card.querySelector('.remove-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.removeProgressionCard(cardData.id);
                    });
                    const previewBtn = card.querySelector('.preview-card');
                    if (previewBtn) {
                        previewBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            playChordAudio(cardData.notes, previewBtn.dataset.instrument || 'guitar');
                        });
                    }
                });
            }
            
            // --- Drag and Drop Handlers (Reimplemented) ---
            
            handleDragStart(e) {
                const card = e.target.closest('.chord-card');
                if (!card) return;
                
                e.dataTransfer.setData('text/plain', card.dataset.id);
                if (card.dataset.chordName) {
                    // Allow dragging from Progression into Segment Composer
                    e.dataTransfer.setData('application/x-chord-name', card.dataset.chordName);
                    e.dataTransfer.setData('application/x-chord', JSON.stringify({ name: card.dataset.chordName, bars: 1 }));
                }
                e.dataTransfer.effectAllowed = 'move';
                card.classList.add('dragging');
                this.draggedItem = card;
            }

            handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const container = this.dom.progressionContainer;
                const target = e.target.closest('.chord-card');
                
                if (!target || target === this.draggedItem) return;

                const targetRect = target.getBoundingClientRect();
                // Determine if dropping before or after the target card based on mouse position
                const insertBefore = e.clientX < targetRect.left + targetRect.width / 2;
                
                if (this.draggedItem) {
                    if (insertBefore) {
                        container.insertBefore(this.draggedItem, target);
                    } else {
                        container.insertBefore(this.draggedItem, target.nextSibling);
                    }
                }
            }
            
            handleDrop(e) {
                e.preventDefault();
                const id = e.dataTransfer.getData('text/plain');
                const droppedCard = document.querySelector(`.chord-card[data-id="${id}"]`);
                
                if (droppedCard) {
                    droppedCard.classList.remove('dragging');
                    
                    // Re-sort the underlying progression array based on the DOM order
                    const newOrderIds = Array.from(this.dom.progressionContainer.querySelectorAll('.chord-card')).map(card => card.dataset.id);
                    const newProgression = newOrderIds.map(newId => this.progression.find(card => card.id === newId));
                    
                    this.progression = newProgression.filter(c => c); 
                    
                    this.renderProgression(); // Re-render to update index numbers
                    this.saveProgression();
                }
                this.draggedItem = null;
            }

            handleDragLeave(e) {
                 if (this.draggedItem) {
                    // This is a subtle fix for drag leave behavior
                    // In simple dnd, we often don't need this, but for cleanup:
                    if (!this.dom.progressionContainer.contains(e.relatedTarget)) {
                       this.draggedItem.classList.remove('dragging');
                    }
                }
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            window.fretboardApp = new FretboardApp();
        });

    </script>

    <style>
        .seg-chord { user-select: none; }
        .seg-chord.playing { outline: 3px solid #4f46e5; outline-offset: 2px; }
        .seg-segment .seg-dup, .seg-segment .seg-del { opacity: 0; transition: opacity .15s ease; }
        .seg-segment:hover .seg-dup, .seg-segment:hover .seg-del { opacity: 1; }
        .seg-overlay { position: absolute; border-radius: 14px; box-sizing: border-box; pointer-events: none; }
        .seg-overlay-selection { border: 2px dashed rgba(245, 158, 11, 0.9); background-color: rgba(251, 191, 36, 0.1); z-index: 40; }
        .seg-overlay-group { pointer-events: auto; border: 2px solid rgba(14, 165, 233, 0.85); background-color: rgba(14, 165, 233, 0.08); z-index: 30; transition: border 0.15s ease, box-shadow 0.15s ease; }
        .seg-overlay-group.is-selected { border: 3px solid rgba(245, 158, 11, 0.95); background-color: rgba(251, 191, 36, 0.14); box-shadow: 0 8px 18px -12px rgba(251,191,36,0.7); z-index: 50; }
        .seg-overlay-group.is-editing { pointer-events: none; }
        .seg-overlay-toolbar { position: absolute; top: -2.6rem; left: 50%; transform: translateX(-50%); display: flex; gap: 0.5rem; pointer-events: auto; z-index: 60; }
        .seg-overlay-toolbar button { pointer-events: auto; }
        .seg-overlay-toolbar-selection { top: auto; }
        .seg-track { overflow-x: auto; padding-bottom: 0.5rem; }
        .seg-track-inner { position: relative; display: flex; flex-direction: column; align-items: flex-start; gap: 0.3rem; min-width: 100%; }
        .seg-ruler { display: flex; align-items: stretch; height: 34px; border: 1px solid #e2e8f0; border-bottom: none; border-radius: 12px 12px 0 0; background-color: #f8fafc; color: #475569; font-size: 0.75rem; font-weight: 600; letter-spacing: 0.04em; }
        .seg-ruler-bar { position: relative; display: flex; align-items: center; justify-content: center; }
        .seg-ruler-bar::after { content: ''; position: absolute; right: 0; top: 18%; bottom: 18%; width: 1px; background-color: #cbd5e1; }
        .seg-ruler-bar:last-child::after { display: none; }
        .seg-drop-wrapper { display: flex; align-items: center; gap: 0.5rem; }
        .seg-drop { flex: 1; display: flex; align-items: stretch; position: relative; background-color: #ffffff; border: 1px solid #e2e8f0; border-top: none; border-radius: 0 0 12px 12px; min-height: 84px; padding: 0.75rem 0; }
        .seg-drop::before { content: ''; position: absolute; inset: 0; border-radius: inherit; border: 2px dashed rgba(148, 163, 184, 0.35); pointer-events: none; opacity: 0; transition: opacity 0.2s ease; }
        .seg-drop.is-empty::before { opacity: 1; }
        .seg-drop-placeholder { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; color: #94a3b8; font-size: 0; pointer-events: none; border: 2px dashed rgba(148, 163, 184, 0.6); border-radius: 12px; }
        .seg-drop-placeholder__plus { display: block; font-size: 2.5rem; font-weight: 600; line-height: 1; color: rgba(148, 163, 184, 0.85); }
        .seg-drop-helper { flex: 0 0 96px; width: 96px; margin: 0 0.35rem 0 0; border: 2px dashed rgba(148, 163, 184, 0.9); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; color: rgba(148, 163, 184, 0.9); background: rgba(255, 255, 255, 0.9); cursor: pointer; pointer-events: auto; transition: border-color 0.2s ease, color 0.2s ease, opacity 0.2s ease; height: 84px; }
        .seg-drop-helper.is-active { border-color: rgba(99, 102, 241, 0.85); color: #312e81; opacity: 1; }
        .seg-chord { border-right: 1px solid #e2e8f0; padding: 0.75rem 0.5rem; height: 100%; }
        .seg-chord:last-child { border-right: none; }
        .seg-chord .seg-duration-label { position: absolute; right: 0.5rem; bottom: 0.35rem; font-size: 0.65rem; font-weight: 600; letter-spacing: 0.04em; opacity: 0.75; text-transform: uppercase; }
    </style>

    <script>
    (function(){
        // --- Utilities ---
        const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
        const NAME_TO_SEMI = {C:0,'C#':1,Db:1,D:2,'D#':3,Eb:3,E:4,F:5,'F#':6,Gb:6,G:7,'G#':8,Ab:8,A:9,'A#':10,Bb:10,B:11};
        const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
        const BAR_UNIT_PX = 96;

        function parseChord(name){
            if(!name) return {root:"C", type:"maj", intervals:[0,4,7]};
            name = name.trim();
            // Extract root (A-G with optional #/b)
            const m = name.match(/^([A-G](?:#|b)?)(.*)$/i);
            if(!m) return {root:"C", type:"maj", intervals:[0,4,7]};
            const root = m[1].toUpperCase().replace('B#','C').replace('E#','F');
            const qual = (m[2]||'').trim().toLowerCase();
            // Map quality to intervals
            let type = 'maj', iv=[0,4,7];
            if(qual === 'm' || qual.startsWith('min')) { type='min'; iv=[0,3,7]; }
            else if(qual.startsWith('dim')) { type='dim'; iv=[0,3,6]; }
            else if(qual.startsWith('aug') || qual.includes('+')) { type='aug'; iv=[0,4,8]; }
            else if(qual === '7' || qual.endsWith('7') && !qual.includes('maj')) { type='7'; iv=[0,4,7,10]; }
            else if(qual.includes('maj7')) { type='maj7'; iv=[0,4,7,11]; }
            else if(qual.includes('m7')) { type='m7'; iv=[0,3,7,10]; }
            return {root,type,intervals:iv};
        }

        function chordToMidiNotes(chord){
            const semi = NAME_TO_SEMI[chord.root] ?? 0;
            // Voice near C3..B3
            const base = 48; // C3
            const rootMidi = base + semi;
            const notes = chord.intervals.map(i=>rootMidi + i);
            // Keep top note not too muddy; if too low, shift up an octave
            while(notes[notes.length-1] < 60) {
                for(let i=0;i<notes.length;i++) notes[i]+=12;
                if(notes[notes.length-1]>=60) break;
            }
            return notes;
        }

        // --- Audio Engine ---
        class AudioEngine{
            constructor(){
                this.ctx = null;
                this.events = [];
                this.running = false;
            }
            ensure(){ if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); return this.ctx; }
            stop(){
                this.running = false;
                // stop scheduled nodes
                this.events.forEach(e=>{ try{ if(e.stop) e.stop(); }catch{} });
                this.events = [];
            }
            secondsPerBeat(bpm,den){ return (60/Math.max(30,bpm)) * (4/den); }
            scheduleTick(t,accent=false){
                const ctx=this.ensure();
                const o=ctx.createOscillator();
                const g=ctx.createGain();
                o.type='square';
                o.frequency.value = accent? 1400: 1000;
                g.gain.setValueAtTime(0.0001, t);
                g.gain.exponentialRampToValueAtTime(0.4, t+0.005);
                g.gain.exponentialRampToValueAtTime(0.0001, t+0.04);
                o.connect(g).connect(ctx.destination);
                o.start(t); o.stop(t+0.05);
                this.events.push(o);
            }
            playChord(notes, tStart, dur){
                const ctx=this.ensure();
                const voices = notes.map(n=>{
                    const o=ctx.createOscillator();
                    const g=ctx.createGain();
                    o.type='sawtooth';
                    const freq = 440*Math.pow(2,(n-69)/12);
                    o.frequency.setValueAtTime(freq, tStart);
                    g.gain.setValueAtTime(0.0001, tStart);
                    g.gain.exponentialRampToValueAtTime(0.25, tStart+0.02);
                    g.gain.exponentialRampToValueAtTime(0.0001, tStart+dur-0.02);
                    o.connect(g).connect(ctx.destination);
                    o.start(tStart);
                    o.stop(tStart+dur);
                    return o;
                });
                this.events.push(...voices);
            }
        }

        // --- DOM helpers ---
        const $ = sel => document.querySelector(sel);
        const $$ = sel => Array.from(document.querySelectorAll(sel));

        // --- App State ---
        const state = {
            segments: [], // {id, name, chords:[{id,name,bars}], selection:{anchor:number|null, indices:Set}, groups:[{id,start,end}]}
            playingTimers: [],
            engine: new AudioEngine(),
            ids: 0,
            groupIds: 0,
            groupEdit: null, // {segId, groupId}
            selectedGroup: null, // {segId, groupId}
            chordIds: 0
        };

        const sanitizeBars = (value)=>{
            if (typeof value === 'string' && value.includes('/')) {
                const [num, den] = value.split('/').map(n => parseInt(n.trim(), 10));
                if (Number.isFinite(num) && Number.isFinite(den) && den > 0) {
                    return num / den;
                }
            }
            const num = parseFloat(value);
            return Number.isFinite(num) && num > 0 ? num : 1;
        };

        function formatBarLabel(bars) {
            if (bars < 1) {
                // หาเศษส่วนที่ใกล้เคียงที่สุด
                for (let den = 2; den <= 32; den++) {
                    const num = 1;
                    const fraction = num / den;
                    if (Math.abs(bars - fraction) < 0.001) {
                        return `${num}/${den}`;
                    }
                }
                // ถ้าไม่เจอเศษส่วนที่ตรง ให้แสดงทศนิยม
                return bars.toFixed(3);
            } else if (bars === 1) {
                return '1 bar';
            } else {
                // ตรวจสอบว่าเป็นจำนวนเต็มหรือไม่
                if (Math.abs(bars - Math.round(bars)) < 0.001) {
                    return `${Math.round(bars)} bars`;
                } else {
                    return `${bars.toFixed(2)} bars`;
                }
            }
        }

        function showBarFractionModal(currentBars, callback) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50';
            modal.style.zIndex = '9999';
            
            const dialog = document.createElement('div');
            dialog.className = 'bg-white rounded-lg shadow-2xl p-6 max-w-md w-full mx-4';
            
            const title = document.createElement('h3');
            title.className = 'text-xl font-semibold mb-4 text-gray-800';
            title.textContent = 'เลือกจำนวนบาร์ (Bar Duration)';
            
            const grid = document.createElement('div');
            grid.className = 'grid grid-cols-4 sm:grid-cols-6 gap-2 max-h-96 overflow-y-auto';
            
            // สร้างตัวเลือก: 1/1, 1/2, 1/3, ... 1/32
            const fractions = [];
            for (let i = 1; i <= 32; i++) {
                fractions.push({ label: `1/${i}`, value: 1/i });
            }
            // เพิ่มตัวเลือกสำหรับหลายบาร์ (2, 3, 4, ...)
            for (let i = 2; i <= 8; i++) {
                fractions.push({ label: `${i}`, value: i });
            }
            
            fractions.forEach(frac => {
                const btn = document.createElement('button');
                btn.className = 'px-3 py-2 rounded-md border-2 transition-all text-sm font-medium';
                btn.textContent = frac.label;
                
                // ตรวจสอบว่าเป็นค่าปัจจุบันหรือไม่
                const isCurrent = Math.abs(frac.value - currentBars) < 0.001;
                if (isCurrent) {
                    btn.className += ' bg-indigo-600 text-white border-indigo-600';
                } else {
                    btn.className += ' bg-white text-gray-700 border-gray-300 hover:bg-indigo-50 hover:border-indigo-400';
                }
                
                btn.addEventListener('click', () => {
                    callback(frac.value);
                    document.body.removeChild(modal);
                });
                
                grid.appendChild(btn);
            });
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'mt-4 w-full bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg';
            closeBtn.textContent = 'ยกเลิก';
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            dialog.appendChild(title);
            dialog.appendChild(grid);
            dialog.appendChild(closeBtn);
            modal.appendChild(dialog);
            
            // ปิดเมื่อคลิกนอก dialog
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            document.body.appendChild(modal);
        }

        function makeChord(name, bars = 1){
            return { id: 'ch_'+(++state.chordIds), name: name || '', bars: sanitizeBars(bars) };
        }

        function ensureChordObject(ch){
            if (typeof ch === 'string') return makeChord(ch);
            if (!ch || typeof ch !== 'object') return makeChord('');
            if (!ch.id) ch.id = 'ch_'+(++state.chordIds);
            ch.name = ch.name || '';
            ch.bars = sanitizeBars(ch.bars);
            return ch;
        }

        function cloneChord(ch){
            const base = ensureChordObject(ch);
            return makeChord(base.name, base.bars);
        }

        function chordFromInput(input){
            if (typeof input === 'string') return makeChord(input);
            if (input && typeof input === 'object') return makeChord(input.name, input.bars);
            return makeChord('');
        }

        // --- UI Rendering ---
        function renderPalette(){
            const rootMaj = NOTES.map(n=>n);
            const rootMin = NOTES.map(n=>n+"m");
            const extras = ['maj7','m7','7'].flatMap(q=>['C','D','E','F','G','A','B'].map(n=>n+q)).slice(0,7);
            const items = [...rootMaj, ...rootMin, ...extras];
            const wrap = $('#seg-palette');
            wrap.innerHTML='';
            items.forEach(ch=>{
                const el=document.createElement('div');
                el.className='seg-chord inline-flex items-center justify-center px-3 py-2 rounded-md bg-indigo-600 text-white shadow cursor-grab select-none';
                el.textContent=ch;
                el.draggable=true;
                el.dataset.chord=ch;
                el.addEventListener('dragstart',ev=>{
                    ev.dataTransfer.setData('text/plain', ch);
                    ev.dataTransfer.setData('application/x-chord-name', ch);
                    ev.dataTransfer.setData('application/x-chord', JSON.stringify({ name: ch, bars: 1 }));
                });
                wrap.appendChild(el);
            });
        }

        function addSegment(name='Intro'){
            state.segments.push({
                id: 'seg_'+(++state.ids), name,
                chords: [],
                selection: { anchor: null, indices: new Set() },
                groups: []
            });
            renderSegments();
        }

        function duplicateSegment(id){
            const idx = state.segments.findIndex(s=>s.id===id);
            if(idx<0) return;
            const s = state.segments[idx];
            const copyGroups = s.groups.map(g=>({ id: 'grp_'+(++state.groupIds), start: g.start, end: g.end }));
            const copyChords = s.chords.map(ch=>cloneChord(ch));
            const copy = {
                id:'seg_'+(++state.ids),
                name: s.name+' (copy)',
                chords: copyChords,
                selection: { anchor: null, indices: new Set() },
                groups: copyGroups
            };
            state.segments.splice(idx+1,0,copy);
            renderSegments();
        }

        function removeSegment(id){
            state.segments = state.segments.filter(s=>s.id!==id);
            if (state.selectedGroup && state.selectedGroup.segId===id) state.selectedGroup=null;
            if (state.groupEdit && state.groupEdit.segId===id) state.groupEdit=null;
            renderSegments();
        }

        function removeChord(segId, idx){
            const s=state.segments.find(s=>s.id===segId); if(!s) return;
            s.chords.splice(idx,1); renderSegments();
        }

        function insertChord(segId, chord, index=null){
            const s=state.segments.find(s=>s.id===segId); if(!s) return;
            const chordObj = chordFromInput(chord);
            if (index===null || index<0 || index>=s.chords.length) s.chords.push(chordObj);
            else s.chords.splice(index,0,chordObj);
            renderSegments();
        }

        function normalizeGroups(seg){
            // Remove invalid groups and clamp ranges
            const max = seg.chords.length - 1;
            seg.groups = seg.groups
                .map(g=>({ ...g, start: clamp(Math.min(g.start,g.end),0,Math.max(0,max)), end: clamp(Math.max(g.start,g.end),0,Math.max(0,max)) }))
                .filter(g=> g.start <= g.end && max >= 0);
        }

        function exitGroupEdit(){ state.groupEdit = null; renderSegments(); }

        function renderSegments(){
            const list = $('#seg-list');
            list.innerHTML='';
            state.segments.forEach(seg=>{
                normalizeGroups(seg);
                seg.chords = seg.chords.map(ch=>ensureChordObject(ch));
                if (!seg.selection){
                    seg.selection = { anchor: null, indices: new Set() };
                } else {
                    if (!(seg.selection.indices instanceof Set)){
                        seg.selection.indices = new Set(seg.selection.indices ? Array.from(seg.selection.indices) : []);
                    }
                }
                if (!Array.isArray(seg.groups)) seg.groups = [];
                const box = document.createElement('div');
                box.className='seg-segment border rounded-lg p-3 mb-3 bg-gray-50';
                box.dataset.id=seg.id;
                box.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <input class="seg-name text-base font-semibold bg-transparent focus:outline-none px-1 rounded hover:bg-white focus:bg-white" value="${seg.name}" />
                        <div class="flex items-center gap-2">
                            <button class="seg-dup text-xs bg-sky-600 hover:bg-sky-700 text-white px-2 py-1 rounded">Duplicate</button>
                            <button class="seg-del text-xs bg-rose-600 hover:bg-rose-700 text-white px-2 py-1 rounded">Delete</button>
                        </div>
                    </div>
                    <div class="seg-track">
                        <div class="seg-track-inner">
                            <div class="seg-ruler"></div>
                            <div class="seg-drop"></div>
                        </div>
                    </div>
                    `;
                list.appendChild(box);
                const track = box.querySelector('.seg-track');
                const trackInner = box.querySelector('.seg-track-inner');
                const ruler = box.querySelector('.seg-ruler');
                const drop = box.querySelector('.seg-drop');
                drop.innerHTML = '';
                ruler.innerHTML = '';
                const dropWrapper = document.createElement('div');
                dropWrapper.className = 'seg-drop-wrapper';
                drop.parentNode.insertBefore(dropWrapper, drop);
                dropWrapper.appendChild(drop);
                const computeOverlayRect = (indices, pad=4)=>{
                    if (!indices.length) return null;
                    let minLeft=Infinity, maxRight=-Infinity, minTop=Infinity, maxBottom=-Infinity;
                    const host = drop.getBoundingClientRect();
                    for (const idx of indices){
                        const el = drop.querySelector(`.seg-chord[data-idx="${idx}"]`);
                        if (!el) return null;
                        const rect = el.getBoundingClientRect();
                        if (rect.left < minLeft) minLeft = rect.left;
                        if (rect.right > maxRight) maxRight = rect.right;
                        if (rect.top < minTop) minTop = rect.top;
                        if (rect.bottom > maxBottom) maxBottom = rect.bottom;
                    }
                    return {
                        left: minLeft - host.left - pad,
                        top: minTop - host.top - pad,
                        width: maxRight - minLeft + pad*2,
                        height: maxBottom - minTop + pad*2
                    };
                };
                const totalBarsRaw = seg.chords.reduce((sum,ch)=>sum + ch.bars, 0);
                const totalBars = Math.max(totalBarsRaw, 1);
                const trackWidth = totalBars * BAR_UNIT_PX;
                const containerWidth = track ? track.clientWidth : 0;
                const effectiveWidth = Math.max(trackWidth, containerWidth);
                trackInner.style.minWidth = effectiveWidth + 'px';
                trackInner.style.width = effectiveWidth + 'px';
                ruler.style.width = trackWidth + 'px';
                drop.style.width = trackWidth + 'px';
                drop.style.minWidth = trackWidth + 'px';
                for (let barIdx = 0; barIdx < totalBars; barIdx++){
                    const barEl = document.createElement('div');
                    barEl.className = 'seg-ruler-bar';
                    barEl.style.flex = `0 0 ${BAR_UNIT_PX}px`;
                    barEl.style.width = `${BAR_UNIT_PX}px`;
                    barEl.textContent = `Bar ${barIdx + 1}`;
                    ruler.appendChild(barEl);
                }
                // Populate chords
                seg.chords.forEach((ch,i)=>{
                    const chordWidth = ch.bars * BAR_UNIT_PX;
                    const c = document.createElement('div');
                    c.className='group seg-chord relative flex flex-col items-center justify-center rounded-md bg-indigo-600 text-white shadow cursor-grab select-none';
                    c.draggable=true;
                    c.dataset.chord = ch.name;
                    c.dataset.idx = i;
                    c.dataset.id = ch.id;
                    c.dataset.bars = String(ch.bars);
                    c.style.flex = `0 0 ${chordWidth}px`;
                    c.style.width = `${chordWidth}px`;
                    c.style.minWidth = `${chordWidth}px`;
                    c.innerHTML = `
                        <span class="text-lg font-semibold tracking-tight">${ch.name || '--'}</span>
                        <span class="seg-duration-label">${formatBarLabel(ch.bars)}</span>
                        <div class="absolute -top-2 -right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition">
                            <button class="seg-ch-copy bg-indigo-500 text-white text-[10px] px-1.5 py-0.5 rounded">⧉</button>
                            <button class="seg-ch-del bg-rose-500 text-white text-[10px] px-1.5 py-0.5 rounded">×</button>
                        </div>
                    `;
                    // Selection visual
                    if (seg.selection.indices.has(i)) {
                        c.classList.add('ring-2','ring-amber-400');
                    }
                    // Disabled outside group edit
                    if (state.groupEdit){
                        const ge = state.groupEdit;
                        const g = seg.groups.find(g=>g.id===ge.groupId);
                        const inThisGroup = ge.segId===seg.id && g && i>=g.start && i<=g.end;
                        if (!inThisGroup) {
                            c.style.opacity = '0.5';
                            c.style.pointerEvents = 'none';
                        }
                    }
                    // chord drag
                    c.addEventListener('dragstart',ev=>{
                        ev.dataTransfer.setData('text/plain', ch.name);
                        ev.dataTransfer.setData('application/x-seg-id', seg.id);
                        ev.dataTransfer.setData('application/x-seg-idx', String(i));
                        ev.dataTransfer.setData('application/x-chord-name', ch.name);
                        ev.dataTransfer.setData('application/x-chord', JSON.stringify({ name: ch.name, bars: ch.bars }));
                    });
                    // chord dragover/drop to allow reordering (swap/insert)
                    c.addEventListener('dragover', ev => { ev.preventDefault(); });
                    c.addEventListener('drop', ev => {
                        ev.preventDefault();
                        ev.stopPropagation();
                        // Restrict when editing a group
                        if (state.groupEdit){
                            const ge = state.groupEdit; if (ge.segId !== seg.id) return;
                            const g = seg.groups.find(g=>g.id===ge.groupId); if (!g) return;
                        }
                        const rect = c.getBoundingClientRect();
                        const insertBefore = ev.clientX < rect.left + rect.width/2;
                        const targetIdxBase = parseInt(c.dataset.idx, 10) || 0;
                        let destIndex = insertBefore ? targetIdxBase : targetIdxBase + 1;

                        const srcSegId = ev.dataTransfer.getData('application/x-seg-id');
                        const srcIdxStr = ev.dataTransfer.getData('application/x-seg-idx');
                        const chordPayload = ev.dataTransfer.getData('application/x-chord');
                        let chordData = null;
                        if (chordPayload) {
                            try { chordData = JSON.parse(chordPayload); } catch(err) { chordData = null; }
                        }
                        const chordName = ev.dataTransfer.getData('application/x-chord-name') || ev.dataTransfer.getData('text/plain');

                        if (srcSegId && srcIdxStr !== '') {
                            const source = state.segments.find(s=>s.id===srcSegId);
                            const target = state.segments.find(s=>s.id===seg.id);
                            if (!source || !target) return;
                            const srcIndex = parseInt(srcIdxStr,10);
                            // In edit mode, enforce in-group move only
                            if (state.groupEdit){
                                const ge = state.groupEdit; const g = target.groups.find(g=>g.id===ge.groupId);
                                if (!g) return;
                                if (!(srcIndex>=g.start && srcIndex<=g.end)) return;
                                // adjust destIndex to be within group
                                if (destIndex<g.start) destIndex = g.start;
                                if (destIndex>g.end+1) destIndex = g.end+1;
                            }
                            const [moved] = source.chords.splice(srcIndex,1);
                            if (source.id === target.id && srcIndex < destIndex) destIndex -= 1;
                            target.chords.splice(destIndex,0,moved);
                            // shift groups if moved across
                            if (source.id === target.id){
                                // update group ranges within same segment
                                target.groups.forEach(g=>{
                                    if (srcIndex>=g.start && srcIndex<=g.end){
                                        // moving item within same group range already handled by indices shift below
                                    }
                                    if (srcIndex < destIndex){
                                        // moved forward
                                        if (g.start>srcIndex && g.start<=destIndex) g.start-=1;
                                        if (g.end>=srcIndex && g.end<destIndex) g.end-=1;
                                    } else if (srcIndex > destIndex){
                                        // moved backward
                                        if (g.start>=destIndex && g.start<srcIndex) g.start+=1;
                                        if (g.end>=destIndex && g.end<srcIndex) g.end+=1;
                                    }
                                });
                            }
                            renderSegments();
                        } else if (chordData || chordName) {
                            const target = state.segments.find(s=>s.id===seg.id);
                            if (state.groupEdit){
                                const ge = state.groupEdit; const g = target.groups.find(g=>g.id===ge.groupId); if (!g) return;
                                if (destIndex<g.start) destIndex = g.start;
                                if (destIndex>g.end+1) destIndex = g.end+1;
                            }
                            insertChord(seg.id, chordData || chordName, destIndex);
                        }
                    });
                    // Edit bars via double click
                    c.addEventListener('dblclick', ev => {
                        if (state.groupEdit) return;
                        ev.stopPropagation();
                        showBarFractionModal(ch.bars, (newBars) => {
                            if (newBars !== ch.bars) {
                                ch.bars = newBars;
                                renderSegments();
                            }
                        });
                    });
                    // selection: click / shift-click
                    c.addEventListener('click', (ev)=>{
                        if (state.groupEdit) return; // no selection change during group edit
                        const idx = i;
                        if (ev.shiftKey && seg.selection.anchor!=null){
                            seg.selection.indices.clear();
                            const a = seg.selection.anchor;
                            const lo = Math.min(a, idx), hi=Math.max(a, idx);
                            for(let k=lo;k<=hi;k++) seg.selection.indices.add(k);
                        } else {
                            seg.selection.indices.clear();
                            seg.selection.indices.add(idx);
                            seg.selection.anchor = idx;
                        }
                        renderSegments();
                        ev.stopPropagation();
                    });
                    // chord quick duplicate/delete
                    c.querySelector('.seg-ch-copy').addEventListener('click',()=>{ insertChord(seg.id, ch); });
                    c.querySelector('.seg-ch-del').addEventListener('click',()=>{ removeChord(seg.id, i); });
                    drop.appendChild(c);
                });

                if (seg.chords.length === 0){
                    drop.classList.add('is-empty');
                    const placeholder = document.createElement('div');
                    placeholder.className = 'seg-drop-placeholder';
                    placeholder.innerHTML = '<span class="seg-drop-placeholder__plus">+</span>';
                    drop.appendChild(placeholder);
                    seg.selection.indices.clear();
                    seg.selection.anchor = null;
                } else {
                    drop.classList.remove('is-empty');
                }

                const readIncomingChordValue = (dataTransfer) => {
                    const chordPayload = dataTransfer.getData('application/x-chord');
                    if (chordPayload) {
                        try { return JSON.parse(chordPayload); } catch(err) { /* ignore */ }
                    }
                    const chordName = dataTransfer.getData('application/x-chord-name') || dataTransfer.getData('text/plain');
                    if (chordName) return chordName;
                    return null;
                };

                const insertIncomingChord = (dataTransfer, destIndex) => {
                    const chordValue = readIncomingChordValue(dataTransfer);
                    if (!chordValue) return false;
                    insertChord(seg.id, chordValue, destIndex);
                    return true;
                };

                let dropHelper = null;
                if (seg.chords.length){
                    dropHelper = document.createElement('div');
                    dropHelper.className = 'seg-drop-helper';
                    dropHelper.textContent = '+';
                    dropWrapper.appendChild(dropHelper);
                    dropHelper.addEventListener('dragover', ev=>{
                        ev.preventDefault();
                        dropHelper.classList.add('is-active');
                    });
                    dropHelper.addEventListener('dragleave', ()=>{
                        dropHelper.classList.remove('is-active');
                    });
                    dropHelper.addEventListener('drop', ev=>{
                        ev.preventDefault();
                        ev.stopPropagation();
                        dropHelper.classList.remove('is-active');
                        if (state.groupEdit) return;
                        insertIncomingChord(ev.dataTransfer, seg.chords.length);
                    });
                }

                // Drop handling (append or move to end)
                drop.addEventListener('dragover',ev=>ev.preventDefault());
                drop.addEventListener('drop',ev=>{
                    ev.preventDefault();
                    ev.stopPropagation();
                    if (state.groupEdit){
                        // Disallow dropping at container level during group edit
                        return;
                    }
                    // Helper to compute insert index from mouse X position
                    const computeIndexFromX = (clientX)=>{
                        const cards = Array.from(drop.querySelectorAll('.seg-chord'));
                        for (let idx=0; idx<cards.length; idx++){
                            const r = cards[idx].getBoundingClientRect();
                            const center = r.left + r.width/2;
                            if (clientX < center) return idx;
                        }
                        return cards.length;
                    };
                    // Group move
                    const grpJson = ev.dataTransfer.getData('application/x-group');
                    if (grpJson){
                        const gdat = JSON.parse(grpJson);
                        const destIndex = computeIndexFromX(ev.clientX);
                        moveGroupById(gdat.segId, gdat.groupId, seg.id, destIndex);
                        return;
                    }
                    const srcSegId = ev.dataTransfer.getData('application/x-seg-id');
                    const srcIdxStr = ev.dataTransfer.getData('application/x-seg-idx');
                    const destIndex = computeIndexFromX(ev.clientX);
                    if (srcSegId && srcIdxStr !== '') {
                        const source = state.segments.find(s=>s.id===srcSegId);
                        const target = state.segments.find(s=>s.id===seg.id);
                        if (!source || !target) return;
                        const srcIndex = parseInt(srcIdxStr,10);
                        const [moved] = source.chords.splice(srcIndex,1);
                        let adjustedIndex = destIndex;
                        if (source.id === target.id && srcIndex < destIndex) adjustedIndex -= 1;
                        if (adjustedIndex < 0) adjustedIndex = 0;
                        if (adjustedIndex > target.chords.length) adjustedIndex = target.chords.length;
                        target.chords.splice(adjustedIndex,0,moved);
                        renderSegments();
                        return;
                    }
                    if (insertIncomingChord(ev.dataTransfer, destIndex)) return;
                });

                // Selection toolbar: show when there is a contiguous selection >=2
                const sel = Array.from(seg.selection.indices).sort((a,b)=>a-b);
                const contiguous = sel.length>=2 && sel.every((v,idx)=> idx===0 || v===sel[0]+idx);
                if (sel.length && contiguous){
                    const rect = computeOverlayRect(sel, 6);
                    if (rect){
                        const overlay = document.createElement('div');
                        overlay.className = 'seg-overlay seg-overlay-selection';
                        overlay.style.left = rect.left + 'px';
                        overlay.style.top = rect.top + 'px';
                        overlay.style.width = rect.width + 'px';
                        overlay.style.height = rect.height + 'px';
                        drop.appendChild(overlay);

                        const toolbar = document.createElement('div');
                        toolbar.className = 'seg-overlay-toolbar seg-overlay-toolbar-selection';
                        toolbar.style.left = (rect.left + rect.width / 2) + 'px';
                        toolbar.style.top = (rect.top - 44) + 'px';
                        toolbar.style.transform = 'translateX(-50%)';
                        toolbar.innerHTML = `
                            <button class="seg-make-group bg-amber-500 hover:bg-amber-600 text-white text-xs px-3 py-1 rounded">Group</button>
                        `;
                        drop.appendChild(toolbar);
                        toolbar.querySelector('.seg-make-group').addEventListener('click',(e)=>{
                            e.stopPropagation();
                            const g = { id: 'grp_'+(++state.groupIds), start: sel[0], end: sel[sel.length-1] };
                            seg.groups.push(g);
                            seg.selection.indices.clear(); seg.selection.anchor=null;
                            renderSegments();
                        });
                    }
                }

                // Render existing groups as overlays with actions
                seg.groups.forEach(g=>{
                    const rangeIdx = Array.from({length: g.end - g.start + 1}, (_,o)=>g.start + o);
                    const rect = computeOverlayRect(rangeIdx, 4);
                    if (!rect) return;
                    const overlay = document.createElement('div');
                    const isSel = state.selectedGroup && state.selectedGroup.segId===seg.id && state.selectedGroup.groupId===g.id;
                    const isEditing = state.groupEdit && state.groupEdit.segId===seg.id && state.groupEdit.groupId===g.id;
                    overlay.className = 'seg-overlay seg-overlay-group';
                    if (isSel) overlay.classList.add('is-selected');
                    if (isEditing) overlay.classList.add('is-editing');
                    overlay.style.left = rect.left + 'px';
                    overlay.style.top = rect.top + 'px';
                    overlay.style.width = rect.width + 'px';
                    overlay.style.height = rect.height + 'px';
                    const bar = document.createElement('div');
                    bar.className='seg-overlay-toolbar';
                    bar.style.transition = 'opacity 0.15s ease';
                    bar.innerHTML = `
                        <button class="seg-dup-group bg-sky-600 hover:bg-sky-700 text-white text-xs px-2 py-1 rounded">Duplicate</button>
                        <button class="seg-un-group bg-rose-600 hover:bg-rose-700 text-white text-xs px-2 py-1 rounded">Ungroup</button>
                    `;
                    overlay.appendChild(bar);
                    drop.appendChild(overlay);
                    if (!isEditing){
                        bar.style.opacity = '0';
                        overlay.addEventListener('mouseenter', ()=>{ bar.style.opacity='1'; });
                        overlay.addEventListener('mouseleave', ()=>{ bar.style.opacity='0'; });
                    } else {
                        bar.style.display = 'none';
                    }
                    // drag whole group as a unit
                    overlay.draggable = !isEditing;
                    if (isEditing) overlay.style.pointerEvents = 'none';
                    overlay.addEventListener('dragstart', (e)=>{
                        if (state.groupEdit) { e.preventDefault(); return; }
                        const payload = { segId: seg.id, groupId: g.id };
                        e.dataTransfer.setData('application/x-group', JSON.stringify(payload));
                        e.dataTransfer.setData('text/plain', 'group');
                        e.dataTransfer.effectAllowed = 'move';
                    });
                    overlay.addEventListener('click',(e)=>{
                        e.stopPropagation();
                        state.selectedGroup = { segId: seg.id, groupId: g.id };
                        renderSegments();
                    });
                    // actions
                    bar.querySelector('.seg-dup-group').addEventListener('click',(e)=>{
                        e.stopPropagation();
                        const items = seg.chords.slice(g.start, g.end+1).map(ch=>cloneChord(ch));
                        const insertAt = g.end+1;
                        seg.chords.splice(insertAt,0,...items);
                        // create new group for duplicated
                        const newG = { id: 'grp_'+(++state.groupIds), start: insertAt, end: insertAt+items.length-1 };
                        seg.groups.push(newG);
                        // shift following groups
                        seg.groups.forEach(gg=>{
                            if (gg===newG) return;
                            if (gg.start>=insertAt){ gg.start += items.length; gg.end += items.length; }
                        });
                        state.selectedGroup = { segId: seg.id, groupId: newG.id };
                        renderSegments();
                    });
                    bar.querySelector('.seg-un-group').addEventListener('click',(e)=>{
                        e.stopPropagation();
                        seg.groups = seg.groups.filter(gg=>gg.id!==g.id);
                        if (state.groupEdit && state.groupEdit.groupId===g.id) state.groupEdit=null;
                        if (state.selectedGroup && state.selectedGroup.groupId===g.id) state.selectedGroup=null;
                        renderSegments();
                    });
                    // enter edit mode via double click
                    overlay.addEventListener('dblclick', (e)=>{
                        e.stopPropagation();
                        state.groupEdit = { segId: seg.id, groupId: g.id };
                        state.selectedGroup = { segId: seg.id, groupId: g.id };
                        renderSegments();
                    });
                });

                // Exit group edit by clicking outside
                document.addEventListener('click', (ev)=>{
                    if (!state.groupEdit) return;
                    const ge = state.groupEdit;
                    // If click inside this segment drop and within overlay, ignore
                    if (drop.contains(ev.target)) return; // clicked outside this segment area
                    exitGroupEdit();
                }, { once: true });

                // Clear selection when clicking empty area (not in edit mode)
                drop.addEventListener('click', (e)=>{
                    if (state.groupEdit) return;
                    if (e.target === drop){
                        seg.selection.indices.clear(); seg.selection.anchor=null; state.selectedGroup = null; renderSegments();
                    }
                });

                // Header actions
                box.querySelector('.seg-dup').addEventListener('click',()=>duplicateSegment(seg.id));
                box.querySelector('.seg-del').addEventListener('click',()=>removeSegment(seg.id));
                box.querySelector('.seg-name').addEventListener('change',e=>{ seg.name = e.target.value; });
            });
        }

        // --- Playback ---
        function clearPlayIndicators(){ $$('#seg-list .seg-chord').forEach(c=>c.classList.remove('playing')); }

        function playAll(){
            stopAll();
            const bpm = parseFloat($('#seg-bpm').value)||100;
            const num = parseInt($('#seg-time-num').value)||4;
            const den = parseInt($('#seg-time-den').value)||4;
            const withClick = $('#seg-metronome').checked;
            const ctx = state.engine.ensure();
            const spb = state.engine.secondsPerBeat(bpm, den);
            const bar = spb * num;
            let t = ctx.currentTime + 0.1;
            let elapsedBars = 0;

            // Schedule chords per segment
            state.segments.forEach(seg=>{
                seg.chords.forEach((ch, idx)=>{
                    const chordShape = parseChord(ch.name);
                    const midi = chordToMidiNotes(chordShape);
                    const chordBars = ch.bars || 1;
                    const chordDuration = bar * chordBars;
                    state.engine.playChord(midi, t, chordDuration);
                    // UI indicator
                    const markerDelay = (t - ctx.currentTime) * 1000;
                    const clearDelay  = ((t + chordDuration) - ctx.currentTime) * 1000;
                    const cardEl = Array.from($('#seg-list').querySelectorAll('.seg-segment'))
                        .find(el=>el.dataset.id===seg.id)
                        ?.querySelectorAll('.seg-chord')[idx];
                    if(cardEl){
                        const onTimer = setTimeout(()=>{ clearPlayIndicators(); cardEl.classList.add('playing'); }, markerDelay);
                        const offTimer = setTimeout(()=>{ cardEl.classList.remove('playing'); }, clearDelay);
                        state.playingTimers.push(onTimer, offTimer);
                    }
                    t += chordDuration;
                    elapsedBars += chordBars;
                });
            });

            // Metronome ticks
            if(withClick && elapsedBars>0){
                const totalBeats = elapsedBars * num;
                let tickTime = ctx.currentTime + 0.1;
                for(let b=0; b<totalBeats; b++){
                    const accent = (b % num)===0;
                    state.engine.scheduleTick(tickTime, accent);
                    tickTime += spb;
                }
            }
            state.engine.running = true;
        }

        function stopAll(){
            state.engine.stop();
            state.playingTimers.forEach(id=>clearTimeout(id));
            state.playingTimers = [];
            clearPlayIndicators();
        }

        // Move a whole group to another position (or segment)
        function moveGroupById(srcSegId, groupId, destSegId, destIndex){
            const src = state.segments.find(s=>s.id===srcSegId); if(!src) return;
            const g = src.groups.find(x=>x.id===groupId); if(!g) return;
            const len = g.end - g.start + 1;
            if (destIndex<0) destIndex=0;
            // Same segment move
            if (srcSegId === destSegId){
                // Ignore drops inside the group
                if (destIndex>=g.start && destIndex<=g.end+1) return;
                const items = src.chords.splice(g.start, len);
                // Adjust destIndex after removal
                let insertAt = destIndex;
                if (destIndex > g.end) insertAt = destIndex - len;
                src.chords.splice(insertAt, 0, ...items);
                // Compute oldStart/oldEnd before updating
                const oldStart = g.start; const oldEnd = g.end;
                // Update this group's range
                const shift = insertAt - oldStart;
                g.start = oldStart + shift; g.end = oldEnd + shift;
                // Update other groups indices
                src.groups.forEach(gg=>{
                    if (gg.id===g.id) return;
                    if (insertAt < oldStart){
                        // moved backward; indices between insertAt..oldStart-1 shift right
                        if (gg.start>=insertAt && gg.start<oldStart) { gg.start+=len; gg.end+=len; }
                    } else {
                        // moved forward; indices between oldEnd+1..insertAt-1 shift left
                        if (gg.start>oldEnd && gg.start<insertAt) { gg.start-=len; gg.end-=len; }
                    }
                });
                state.selectedGroup = { segId: src.id, groupId: g.id };
                renderSegments();
                return;
            }
            // Cross segment move
            const dest = state.segments.find(s=>s.id===destSegId); if(!dest) return;
            const items = src.chords.splice(g.start, len);
            // Shift groups in source after removal
            src.groups = src.groups.filter(gg=>gg.id!==g.id).map(gg=>{
                if (gg.start>g.end){ gg.start-=len; gg.end-=len; }
                return gg;
            });
            if (destIndex > dest.chords.length) destIndex = dest.chords.length;
            dest.chords.splice(destIndex,0,...items);
            const newG = { id: 'grp_'+(++state.groupIds), start: destIndex, end: destIndex+len-1 };
            dest.groups.push(newG);
            // Shift following groups in dest
            dest.groups.forEach(gg=>{ if (gg!==newG && gg.start>=destIndex){ gg.start+=len; gg.end+=len; } });
            state.selectedGroup = { segId: dest.id, groupId: newG.id };
            renderSegments();
        }

        // --- Wire up controls ---
        document.addEventListener('DOMContentLoaded', ()=>{
            renderPalette();
            // default two segments like example
            addSegment('Intro');
            addSegment('Verse I');

            $('#seg-add').addEventListener('click', ()=>{
                const name = prompt('ตั้งชื่อ Segment', 'New Segment') || 'New Segment';
                addSegment(name);
            });
            $('#seg-clear').addEventListener('click', ()=>{ state.segments=[]; state.selectedGroup=null; state.groupEdit=null; renderSegments(); stopAll(); });
            $('#seg-play').addEventListener('click', playAll);
            $('#seg-stop').addEventListener('click', stopAll);
            $('#seg-add-custom').addEventListener('click', ()=>{
                const v = ($('#seg-custom-chord').value||'').trim();
                if(!v) return;
                const el=document.createElement('div');
                el.className='seg-chord inline-flex items-center justify-center px-3 py-2 rounded-md bg-indigo-600 text-white shadow cursor-grab select-none';
                el.textContent=v; el.draggable=true; el.dataset.chord=v;
                el.addEventListener('dragstart',ev=>{
                    ev.dataTransfer.setData('text/plain', v);
                    ev.dataTransfer.setData('application/x-chord-name', v);
                    ev.dataTransfer.setData('application/x-chord', JSON.stringify({ name: v, bars: 1 }));
                });
                $('#seg-palette').appendChild(el);
                $('#seg-custom-chord').value='';
            });
            // Escape to exit group edit
            document.addEventListener('keydown',(e)=>{
                if (e.key === 'Escape' && state.groupEdit){ exitGroupEdit(); }
            });
        });
    })();
    </script>
</body>
</html>
